## Copyright (C) 2023 Gabriel Zalles
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <https://www.gnu.org/licenses/>.

## example for 3D array with 16 channels using the ADA PDM mics. 
## measured 3 poses (0, 90, 45).  

## P1 = horizontal meas = 0 degs || P2 = vertical meas = 90 degs
## P3 = diagonal meas = 45 degs.

## this array has 8 channels in octophonic config, and another 8 pointing up
## (+20 deg elev) sort of like the Atmos set-up (irregular spacing)

## we can't sample all harmonics with P1 so we have 3 sets of meas.
## P1 for W, Y, X, V, U, Q, P [0]
## P2 for Z, R, K, T, M [90]
## P3 for O, S, L, N [45]

## Author: Gabriel Zalles <gabrielzalles@Gabriels-MacBook-Pro.local>
## Created: 2023-03-10

clc; clear all; close all;
pkg load signal;
pkg load json;

#load speaker filter (generated by REW) using calibrated u-mic.
# make sure to include calibration file
cd spkr-ir;
[spkr_ir, Fs] = audioread("CPMC365-Genelec Mar 9-filters-44k.wav");
cd ..
plot_on = 1;
export_on = 1;

#remove leading and trailing zeros
#spkr_ir = spkr_ir(find(spkr_ir,1,'first'):find(spkr_ir,1,'last'));

#plot the filter in the time domain
if plot_on
  figure(1)
  plot(spkr_ir);
  axis tight; grid on;
  title("Speaker Compensation Filter (Time Domain)");
  ylabel("Amplitude");
  xlabel("Samples");
endif

#FFT the spkr response 
Nfft = 1024;
SPKR_IR = fft(spkr_ir, Nfft);
SPKR_IR_MAG = abs(SPKR_IR); #get mag

#plot the spkr response
freqVec = linspace(0, Fs/2, Nfft/2); #freq vector for plotting

if plot_on
  figure(2)
  plot(freqVec, 20*log10(SPKR_IR_MAG(1:end/2)));
  axis tight; grid on;
  title("Speaker Compensation Filter (Freq Domain)");
  ylabel("Magnitude in dB");
  xlabel("Frequency in Hz");
endif

#REW already windows (if we ask it to) the IR and provides a compensation EQ
#this IR was not windowed

#ScanIR does not window the data.

delta = zeros(Nfft, 1);
delta(1) = 1; #delta function

#we load the 3 poses we have for the 3OA mic
#from CPMC365 
cd data/diss;
#load mems measurement MP34DT01-M (non-anechoic), ScanIR
#using the ADA PDM mics
load mar9-16ch-ADA-clean-PDM-P1.mat; 
s1 = data; #only one pose measured (horizontal)
load mar9-16ch-ADA-clean-PDM-P2-side.mat; 
s2 = data; #only one pose measured (vertical) [from side]
load mar9-16ch-ADA-clean-PDM-P3-side.mat; 
s3 = data; #only one pose measured (diagonal) [from side]

cd ../..;

#get params from data
D = size(s1, 2); #get number of meas in data (directions)
ir = s1.IR; #get the first ir (has Q columns)
ir_len = size(ir, 1); #get length of ir 
Q = size(ir, 2); #determine the number of sensors

Fs3 = specs.sampleRate; #get sampling rate of ir

#extract all the ir from structs
#TODO: add 4th dim to struct (varargin)
ir_all1 = getIR(s1, D, ir_len, Q); #custom function to extract IR
ir_all2 = getIR(s2, D, ir_len, Q); #custom function to extract IR
ir_all3 = getIR(s3, D, ir_len, Q); #custom function to extract IR

gain = 60;

ir_all1 = ir_all1 .* gain; #make IRs gain times louder
ir_all2 = ir_all2 .* gain; #make IRs gain times louder
ir_all3 = ir_all3 .* gain; #make IRs gain times louder

#we need to apply a windowing function, to prevent spectral leakage 
# (and make first value 0)
winLen = 256;
Ts = 1/Fs;
winT = Ts * winLen; #length of window in seconds
winF = 1/winT; #freq lim of window 
c = 343; #speed of sound
winM = winT * c; #length of window in meters
winT = winT * 1000; #in ms
cutoff = -120;

%display frreq lim in Hz
fprintf('Our window limit (freq) is %0.00f Hz. \n', winF);
fprintf('Our window length (period) is %0.00f ms. \n', winT);
fprintf('Our window length (meters) is %0.00f m. \n', winM);

bm = blackman(winLen); #make window function
win = zeros(ir_len, 1); #init mem for window
win(1:length(bm)/2) = bm(end/2+1:end); #put bm in win var

#function retval = windowIRs(ir_all, D, Q, win);
ir_all1 = windowIRs(ir_all1, D, Q, win); #window the IRs
ir_all2 = windowIRs(ir_all2, D, Q, win); #window the IRs
ir_all3 = windowIRs(ir_all3, D, Q, win); #window the IRs

#plot one set of irs, from first direction (using pose 1)
if plot_on 
  figure(4)
  hold on;
  for q = 1:Q
    #normalized
    plot(ir_all1(1, q, :)); #multiple qs
  endfor
  plot(win); #plot window
  hold off;
  axis tight; grid on;
  title("First IR (Pre-Processing)");
  ylabel("Amplitude");
  xlabel("Samples");
endif

#function retval = helm_filt_IRs (ir_all, D, Q, helm)
#ir_all = helm_filt_IRs(ir_all, D, Q, helm); #apply helm filter

if D == 101 || D == 201
  #removing duplicate response [TODO]
  # 0 degs should be symmetrical.
  ir_all1 = ir_all1(1:D-1, :, :); 
  ir_all2 = ir_all2(1:D-1, :, :); 
  ir_all3 = ir_all3(1:D-1, :, :); 
  D = size(ir_all1, 1); #recalculate D
endif

## filter all data with SPKR_IR 
IR_SINGLE = zeros(Nfft, 1); #init mem for single ir FFTd (Nfft by 1)
  
#first we need to FFT all the irs 
# which we've windowed
IR_ALL1 = FFT_IRs(ir_all1, D, Q, Nfft);#custom helper function 
IR_ALL2 = FFT_IRs(ir_all2, D, Q, Nfft);#custom helper function 
IR_ALL3 = FFT_IRs(ir_all3, D, Q, Nfft);#custom helper function 

#subsequently convolve with speaker EQ filter (compensate)
IR_ALL1 = conv_IRs (IR_ALL1, D, Q, Nfft, SPKR_IR);
IR_ALL2 = conv_IRs (IR_ALL2, D, Q, Nfft, SPKR_IR);
IR_ALL3 = conv_IRs (IR_ALL3, D, Q, Nfft, SPKR_IR);

#plot the FFT of the first meas. (d = 1) for Q sensors
#just for P1 
if plot_on 
  figure(5)
  hold on;
  
  for i = 1:Q
    plot(freqVec, 20*log10(abs(IR_ALL1(1, i, 1:end/2))));    
  endfor
  
  hold off;
  axis tight; grid on;
  title("First IR FFT (Pre-AF EQ) [w/ spkr-EQ] {P1 only}");
  legend("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16");
  ylabel("Magnitude in dB");
  xlabel("Freq in Hz");
endif

#get Q DFRs, then get global DFR and generate 8 calibration filters

#get Q DFRs
DFRs1 = getDFR(IR_ALL1, D, Q, Nfft);
DFRs2 = getDFR(IR_ALL2, D, Q, Nfft);
DFRs3 = getDFR(IR_ALL3, D, Q, Nfft);

# now we have 16 DFRs for each pose
# we want 16 DFRs which average all poses 

P = 3; #number of poses

DFRs_local = zeros(Q, Nfft); 
#local refers to the fact that each capsulee has its own DFR

#here we average all the poses
for q = 1:Q
  DFRs_local(q, :) = (DFRs1(q, :) + DFRs2(q, :) + DFRs3(q, :)) / P;
endfor

#let's plot these DFRs (local)
if plot_on
  figure(6);
  hold on;
  
  for q = 1:1:Q
    
    DFR = DFRs_local(q, :); #extract first DFR
    #these are magnitudes already 
    plot(freqVec, 20*log10(DFR(1:end/2)));#decibel
    
  endfor
  
    axis tight; grid on;
    hold off;
    title("DFRs (LOCAL)");
    legend("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
    
endif

#we could also have one AF EQ for side caps + 1 for top caps
DFR_global = sum(DFRs_local) ./ Q; #for AF EQ

# for the inverse filter we will use the local DFRs and the target
# will be the a delta function (not global DFR)

lim_vec = [0, 80, 17500, Fs/2]; #limit vec for regularization arr. 
regLow = 0.01; #low value for regularization vector

DELTA = fft(delta, Nfft); #get the frequency response of delta 
H_target = DELTA; #reassign variable name to avoid confusion 
binRes = Fs/Nfft; #bin resolution in Hz

#get inverse filters (min phase)
[H_inv, epsilon] = get_inv_filters(lim_vec, regLow, ...
  H_target, DFRs_local, Nfft, Fs, cutoff);

H_inv1 = zeros(1, Nfft); #temp var for plotting

#plot inv filts in freq domain
if plot_on
  figure(7);
  for q = 1:1:Q
    
    H_inv1 = H_inv(q, :); #extract first inv filt
    H_inv1_mag = abs(H_inv1); #get mags
    plot(freqVec, 20*log10(H_inv1_mag(1:end/2)));#decibel
    hold on;
  endfor
    plot(freqVec, 20*log10(epsilon(1:end/2))); #plot epsilon 
    axis tight; grid on;
    hold off;
    title("Inverse Filters (AF Calibration)");
    legend("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
endif

#now the filters are min phase, we can export and apply to our IRs
#A-format calibration (in preparation for plotting)

IR_ALL1 = conv_IRs(IR_ALL1, D, Q, Nfft, H_inv);
IR_ALL2 = conv_IRs(IR_ALL2, D, Q, Nfft, H_inv);
IR_ALL3 = conv_IRs(IR_ALL3, D, Q, Nfft, H_inv);

#TODO: export AF filters, BF filters, enc-mat, test in RPP

# plot EQd A-format signals (only one direction) [[P1]]
if plot_on
  figure(8);
  hold on;
  for q = 1:1:Q
    IR_SINGLE(:, 1) = abs(IR_ALL1(1, q, :));#extract one IR (EQd), get mag
    plot(freqVec, 20*log10(IR_SINGLE(1:end/2)));#decibel
  endfor
    axis tight; grid on;
    hold off;
    title("A-format EQd: Single Direction Phi = 0");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
    
endif

#lets calculate the matrix for encoding in 2D array.

% 8 equally spaced capsules 
% +22.5, -22.5, -67.5, -112.5, -157.5, +157.5, +112.5, +67.5.
% Left    Right  RF     RB      RS     LS      LB      LF 
% Ch1     Ch2    Ch3...

% RF = right front, RB = right back, RS = right surround. 
% top ring elev = 20, bottom ring elev = 0. 

elev1 = 20;
elev2 = 0; 

Q_pos = [+22.5 elev1; -22.5 elev1; -67.5 elev1; -112.5 elev1; ...
        -157.5 elev1; +157.5 elev1; +112.5 elev1; +67.5 elev1; ...
         +22.5 elev2; -22.5 elev2; -67.5 elev2; -112.5 elev2; ...
        -157.5 elev2; +157.5 elev2; +112.5 elev2; +67.5 elev2]; #azi, elev

## shape of our enc-mat 
# (pre-transpose)

     #ACN0 || ACN1 || etc.
# q1  
# q2
# q3
# q4

#this array is irregular, so we might need to invert the enc. mat. 

N = 3; #ambisonic order 
numHarms = (N+1)^2; #equation for 3D arrays
numHarms2D = 2*N + 1;

#simple check
if Q < numHarms
  disp("Q should be bigger than number of harmonics (2D). Poor sampling");
endif

enc_mat = calc_enc_mat(Q_pos, N, Q); #calculate encoding matrix
#enc_mat = pinv(enc_mat);#irregular layout must invert mat

#in order to plot we need to copy the data
if D == 100
  %% duplicate symmetric half
  %% to get 360 degrees. 
  temp = IR_ALL1;               %copy the data 
  temp = flipud(temp);          %flip left/right
  IR_ALL1 = [IR_ALL1; temp];    %append data
  temp = IR_ALL2;               %copy the data 
  temp = flipud(temp);          %flip left/right
  IR_ALL2 = [IR_ALL2; temp];    %append data
  temp = IR_ALL3;               %copy the data 
  temp = flipud(temp);          %flip left/right
  IR_ALL3 = [IR_ALL3; temp];    %append data
  clear temp;                   %we can get rid of the copy
  
  D = 200; 
endif

#now we need to encode all the A-format signals using the enc-mat. 
SH_ALL1 = encode_IRs(enc_mat, D, Q, Nfft, IR_ALL1);
SH_ALL2 = encode_IRs(enc_mat, D, Q, Nfft, IR_ALL2);
SH_ALL3 = encode_IRs(enc_mat, D, Q, Nfft, IR_ALL3);

## P1 for W, Y, X, V, U, Q, P [0] {1, 2, 4, 5, 9, 10, 16}
## P2 for Z, R, K, T, M [90] {3, 7, 13, 6, 12}
## P3 for O, S, L, N [45] {11, 6, 14, 15}

SH_ALL1(:, 3, :) = SH_ALL2(:, 3, :);
SH_ALL1(:, 7, :) = SH_ALL2(:, 7, :);
SH_ALL1(:, 13, :) = SH_ALL2(:, 13, :);
SH_ALL1(:, 6, :) = SH_ALL2(:, 6, :);
SH_ALL1(:, 12, :) = SH_ALL2(:, 12, :);

SH_ALL1(:, 11, :) = SH_ALL3(:, 11, :);
SH_ALL1(:, 8, :) = SH_ALL3(:, 8, :);
SH_ALL1(:, 14, :) = SH_ALL3(:, 14, :);
SH_ALL1(:, 15, :) = SH_ALL3(:, 15, :);

#with the IRs encoded now we should be able to plot the SHs. 
freq2plot = 2000;
k = floor(freq2plot/binRes); #bin for 1000Hz (closest to)
rad_vec = linspace (0, 2*pi, 200); %radian vector 0 to 360

#string for titles in fiigure 9
acn_str = ["W", "Y", "Z", "X", "V", "T", "R", "S", "U", "Q", "O", "M", "K", "L", "N", "P"];

if plot_on
  #close all;
  figure(9)
  
  for harm = 1:1:numHarms
      
      subplot(4, 4, harm);# 2x4 total of 8 spaces, harm = index
      
      SH = SH_ALL1(:, harm, k); #get one harmonic, at bin k
      SH_mag = abs(SH); 
      SH_mag_norm = SH_mag .* 1/(max(SH_mag));#normalize
      #normalize just for this plot
    
      polar(rad_vec, SH_mag_norm); #polar plot
      title(sprintf ("%c 2kHz Normalized", acn_str(harm)));

      #hold on;
     
  endfor
  
  axis tight; grid on;
 
endif

#with the SH now available we can also try B-format EQing
#the idea is to find the max/peak of the SH and try to make f-res flat at that angle

[pk_IRs, SH_max_idx] = getSH_peaks(SH_ALL1, k, Nfft, numHarms);

#let's first plot the response of these peaks 
if plot_on
  
  figure(10);
  
  for harm = 1:numHarms
    plot(freqVec, 20*log10(abs(pk_IRs(harm, 1:end/2))));#decibel
    hold on;
  endfor
  
    axis tight; grid on;
    hold off;
    title("Freq Response of SH Peaks");
    legend("W", "Y", "Z", "X", "V", "T", "R", "S", "U", "Q", "O", "M", "K", "L", "N", "P");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
endif

#note: we have to account for SN3D normalization, make sure the inv filters
#don't mess up the normalization, we can multiply irs by norm coeffs @ the end
norm_coeffs = sn3d_all(numHarms, N); #for B-format EQs

#this is NOT a special case TODO

#get BF calib filts 
[H_inv_BF, epsilon] = get_inv_filters(lim_vec, regLow, H_target, ...
  pk_IRs, Nfft, Fs, cutoff);

#plot inv filts in freq domain for B-format calib. H's
if plot_on
  
  figure(11);
  
  for harm = 1:1:numHarms
    
    H_inv1 = H_inv_BF(harm, :); #extract first inv filt
    H_inv1_mag = abs(H_inv1); #get mags
    plot(freqVec, 20*log10(H_inv1_mag(1:end/2)));#decibel
    hold on;
    
  endfor
  
    axis tight; grid on;
    hold off;
    title("Inverse Filters for B-Format SHs (Peaks)");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
    
endif

#now we need to convolve the SH IRs with these inverse filters 

SH_ALL_EQ = zeros(size(SH_ALL1)); %alloc mem
SH_ALL_EQ = conv_IRs(SH_ALL1, D, numHarms, Nfft, H_inv_BF);

#in order to evaluate their efficacy we have to compare with old SHs IRs
#at various frequencies

freqs2plot = [250, 500, 1000, 2000, 4000, 8000];
bins2plot = floor(freqs2plot/binRes); #bins for freqs (closest to)

disp("Figure 12 intentionally not normalized, to show effect of filter on SH.");

harm2plot = 11; %pick a harmonic to plot

if plot_on
  #close all;
  figure(12)
  
  subplot (1, 2, 1); #left side is EQd plot
  
    for i = 1:length(bins2plot);
      k = bins2plot(i); #get one bin from array 
      SH = SH_ALL_EQ(:, harm2plot, k); #get one harmonic, at bin k
      SH_mag = abs(SH); #get mag
      
      polar(rad_vec, SH_mag); #polar plot
      hold on;
    endfor
  
  title ("Polar Plot of 1 Harmonic (EQd)");
  axis tight; grid on;
  legend("250", "500", "1000", "2000", "4000", "8000");
  hold off;
  
  subplot (1, 2, 2); #right side is not EQd plot
  
    for i = 1:length(bins2plot);
      k = bins2plot(i); #get one bin from array 
      SH = SH_ALL1(:, harm2plot, k); #get one harmonic, at bin k
      SH_mag = abs(SH); #get mag
      
      polar(rad_vec, SH_mag); #polar plot
      hold on;
    endfor

  title ("Polar Plot 1 Harmonic (NOT EQd)");
  axis tight; grid on;
  legend("250", "500", "1000", "2000", "4000", "8000");
  hold off; 
  
endif

#we should also plot the freq response of the peaks, after EQing
if plot_on
  
  figure(13);
  
  for harm = 1:numHarms
    pkDir = SH_max_idx(harm);#get the SH IRs for the peaks 
    pk_IRs(harm, :) = SH_ALL_EQ(pkDir, harm, :); #extract 4 BF IRs (EQd) 
    #one at a time
    plot(freqVec, 20*log10(abs(pk_IRs(harm, 1:end/2))));#decibel
    hold on;
  endfor
  
    axis tight; grid on;
    hold off;
    title("Freq Response of SH Peaks (after EQ)");
    #legend("W", "Y", "X", "V", "U");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
endif

#pkg install "https://github.com/gnu-octave/pkg-json/archive/v1.5.0.tar.gz"
enc_mat_json = jsonencode(enc_mat');

#we simply copy/paste the variable into the JSON file (for IEM MatrixMultiplier plug-in)

#get inverse filter (min phase)
[H_inv_AF_global, epsilon] = get_inv_filters(lim_vec, regLow, ...
  H_target, DFR_global, Nfft, Fs, cutoff);

# plot the freq response of the global DFR (inverse filter) used for AF EQ
if plot_on
  
  figure(14);
  
    plot(freqVec, 20*log10(H_inv_AF_global(1:end/2)));#decibel
    hold on;
    plot(freqVec, 20*log10(DFR_global(1:end/2)));#decibel
    plot(freqVec, 20*log10(H_target(1:end/2))); 
    plot(freqVec, 20*log10(epsilon(1:end/2)));
    hold off;
    axis tight; grid on;
    title("Global DFR (Inverse Filter) for AF Signals");
    legend("Inverse", "Global DFR", "target", "epsilon");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
endif

#get the time domain version of the signal via iFFT
h_inv_AF_global = ifft(H_inv_AF_global, Nfft);
h_inv_AF_global = real(h_inv_AF_global); #return the real part only
h_inv_AF_global = h_inv_AF_global * 1/max(h_inv_AF_global); #normalize

#plot the time domain AF inverse filter (GLOBAL DFR)
if plot_on 
  figure(15)
  
  plot(h_inv_AF_global);
  
  axis tight; grid on;
  title("Time domain AF inverse filter");
  ylabel("Amplitude");
  xlabel("Samples");
endif

cd ../conf/convolver_presets/16ch-ada-3D-3OA/wav; #change dir

#one single filter for all Q capsules
#to be used with kronlachner convolver plug-in

if export_on
  audiowrite("global_AF_44.wav", h_inv_AF_global, 44100);
endif

h_inv_BF_all = zeros(numHarms, Nfft);#mem alloc

for harm = 1:numHarms
  
  H_inv_BF_single = H_inv_BF(harm, :); #get one inverse BF filter
  h_inv_BF_single = ifft(H_inv_BF_single, Nfft);#inverse FFT
  h_inv_BF_single = real(h_inv_BF_single); #remove imaginary vals
  h_inv_BF_single = h_inv_BF_single * 1/max(h_inv_BF_single); #normalize
  h_inv_BF_single = h_inv_BF_single * norm_coeffs(harm);#re-apply SN3D normalization
  #disp(norm_coeffs(harms2keep(harm)));#debug
  filename = sprintf("%i_BF_44.wav", harm);#format string for filename
  
  if export_on
    audiowrite (filename, h_inv_BF_single, 44100);
  endif  
  
  h_inv_BF_all(harm, :) = h_inv_BF_single;
endfor

#plot the time domain BF inverse filter 
if plot_on 
  figure(16)
  
  for harm = 1:numHarms2D
    plot(h_inv_BF_all(harm, :));
    hold on;
    axis tight; grid on;
    title("Time domain BF inverse filters");
    ylabel("Amplitude");
    xlabel("Samples");
  endfor
  
endif


cd ../../../../m #return to main folder

#GCF 17, 18.TODO

#no subplot, a clean plot maker
freqs2plot = [2000, 4000, 6000, 8000];
bins2plot = floor(freqs2plot/binRes); #bins for freqs (closest to)
harm2plot = 11; 

if plot_on
  #close all;
  figure(19)
  
  
    for i = 1:length(bins2plot);
      k = bins2plot(i); #get one bin from array 
      SH = SH_ALL_EQ(:, harm2plot, k); #get one harmonic, at bin k
      SH_mag = abs(SH); #get mag
      
      polar(rad_vec, SH_mag); #polar plot
      hold on;
    endfor
  
  title ("Polar Plot of 1 Harmonic (EQd) using peak BF method");
  axis tight; grid on;
  legend( "2000", "4000", "6000", "8000" );
  hold off;
  
endif

