#script to test the inv-filt function # #this function is not just used to equalize the capsules of the array, but #can also be used to compensate for the frequency response of the speaker used#to capture the impulse responses.clc;clear all; close all;#mems1_mat was single cap meas. on-axis. (see AES143 paper)plot_on = 1; #to plot or not to plotwrite_on = 0; #should we write any audio to disk?cd data/aes143;load mems_1.mat; #load mems measurement ICS-40720 (anechoic), ScanIRcd ../..ir = data.IR; #get just the first measurement (on-axis)#note: the response of the speaker was not accounted for, we would need the #ir of an earthworks mic inside the anechoic chamber with that speaker. Nfft = 2^16; #size of FFT Fs = 41000; #sampling ratebinRes = Fs/Nfft; #bin resolution in HzlfLim1 = 20; #low frequency limit lfLim2 = 200; #upper end of low frequency limit hfLim1 = 16000; #high frequency limithfLim2 = 20000; #upper end of of high frequency limitNyq = Fs/2; #nyquist limitfreqVec = linspace(0, Fs/2, Nfft/2); #freq vector for plotting (W)# discontinuities in FFT, needs windowing (avoid spectral leak)ir(1) = 0; #force first value to be zero (it should be small anyway)bm = blackman(length(ir) * 2); #create window, twice size of irir = ir .* bm(end/2+1:end); #window ir with second half of window#note: between 200 and 8000 Hz reg. value is 0.01#between 20 and 200 decrease linearly from 1 to 0.01#between 200 and 8kHz stays at 0.01, from 8 to 16kHz increase to 1 linearly#reg. value = 1 between 16kHz and Nyq#epsilon is the regularization vectorepsilon = ones(Nfft/2, 1); #get the limiting values as approximate bin numberslfLim1Bin = floor(lfLim1/binRes); lfLim2Bin = floor(lfLim2/binRes); hfLim1Bin = floor(hfLim1/binRes); hfLim2Bin = floor(hfLim2/binRes); #note: could have just done it as a vector and divided once. #if the binRes is too low there will be an index error, this "fixes" itif lfLim1Bin == 0  lfLim1Bin = 1;endifregLow = 0.01; #low value for regularization vector#in order to use linspace we have to calculate number of bins between limitsepsilon(lfLim1Bin:lfLim2Bin, 1) = linspace(1, regLow, lfLim2Bin - lfLim1Bin + 1); epsilon(lfLim2Bin:hfLim1Bin, 1) = regLow; epsilon(hfLim1Bin:hfLim2Bin, 1) = linspace(regLow, 1, hfLim2Bin - hfLim1Bin + 1); #make it symmetric, since FFT of ir is also symmetricepsilon = [epsilon; flipud(epsilon)];#H = the measured frequency response on-axis IR = fft(ir, Nfft); #get the frequency response of IRH = IR; #reassign variable name to avoid confusion#note: H = transfer function.#H_target = the target frequency response delta = zeros(Nfft, 1); #create empty vectordelta(1,1) = 1; #put one in first index (dirac)DELTA = fft(delta, Nfft); #get the frequency response of delta H_target = DELTA; #reassign variable name to avoid confusion #note: we could skip several steps and just use ones(Nfft, 1)#this is for edification. the target is the ideal frequency response.#a delta function is one option, we can also use a different mic as target!#for example we can use the ambeo!!!#call the function#H_inv = inv_filt_f(H, H_target, epsilon);H_inv = (H_target .* conj(H)) ./ (conj(H) .* H + epsilon);H_eq = H_inv .* H; #equalize by convolving inverse filter with IR#plot stuff (magnitude in dB)if plot_on == 1  plot(freqVec, 20*log10(abs(H_eq(1:end/2)))); #plot EQ'ed IR  hold on #overlay plots  plot(freqVec, 20*log10(abs(H(1:end/2)))); #plot original IR  plot(freqVec, 20*log10(abs(H_inv(1:end/2)))); #plot inverse filter  plot(freqVec, 20*log10(abs(H_target(1:end/2)))); #plot target  plot(freqVec, 20*log10(epsilon(1:end/2))); #plot epsilon   axis tight; grid on; #make plot pretty  ylim([-50 20]); #set y limits for plot  title("NK Script w/ Regularization");   ylabel("Magnitude in dB");  xlabel("Frequency in Hz");  legend('equalized','original', 'inverse filt', 'target', 'epsilon');  hold off;endif #the phase response of our filter is wrong, we need to make it minimum phaseS = H_inv; #the complex spectrum we want to make min-phase is the inverse filter#https://ccrma.stanford.edu/~jos/filters/Matlab_listing_mps_m.htmlSM = exp( fft( fold( ifft( log( clipdb(S,-120) )))));sm = ifft(SM); sm = real(sm); #i guess i still have to do this?h_inv = ifft(H_inv);h_inv = real(h_inv); #this one is wrong, used to compare plots. > not min phase#note: #   not sure why i still get complex values...after min phase. ask Tamara.#make sure IRs don't exceed -1 to 1 rangesm = sm .* (1 / max(sm));h_inv = h_inv .* (1 / max(h_inv));#plot of the ir in time domain, the delay is gone.if plot_on == 1   figure(2)  plot(sm);  hold on;  plot(h_inv);  axis tight; grid on;  hold off;    title("Inverse filter after MP Transformation");   ylabel("Amplitude");  xlabel("Samples");  legend("min phase", "original");endif#now we should compare the frequency response of H_inv and sm to make sure things are correct. #we might also want to check out the phase response. if plot_on == 1     figure(3); #phase response of H_inv and sm  plot(unwrap(angle(H_inv(1:end/2)))*180/pi);  hold on;  plot(unwrap(angle(SM(1:end/2)))*180/pi);  hold off;    axis tight; grid on;    title("Phase response before and after");   #ylabel("Amplitude"); #to do  #xlabel("Samples");  legend("Original", "Min Phase");   #don't quite understand the phase response...endifif plot_on == 1     figure(4); #magnitude response of H_inv and sm  plot(freqVec, 20*log10(abs(H_inv(1:end/2))));  hold on;  plot(freqVec, 20*log10(abs(SM(1:end/2))) + 0.5 ); #offset to show they are the same!!!   ### otherwise cant see  hold off;    axis tight; grid on;    title("Magnitude response of H_inv before and after MPS");   ylabel("Magnitude in dB");  xlabel("Frequency in Hz");  legend("Original", "Min Phase");   endif#we can also plot the magnitude response of the original ir (anechoic) #after conv with min.phase filt. however since the mag response is the same #there should be no difference.if write_on == 1   #now let's hear the result  #load audio recorded with ics-40720  [x, fs] = audioread('soprano-ics40720.wav'); #load in a sound to test difference  result_filename = "inv_filt_test.wav";  x = conv(x, sm); #convolve with min phase ir (takes a minute)  x = (x - min(x)) ./ (max(x) - min(x)); #normalize 0 to 1  x = (2 * x) - 1; #adjust range -1 to 1    #soundsc does not really work in octave, lots of artifacts...this is part of the reason  #things sounded broken before. we need to export to listen  audiowrite(result_filename, x, fs);endif#listening to this filter versus the simpler helmholtz filter in "helmholtz_s"#we think the simpler filter sounds better. there is better low-end response. #the NK function is still useful for analysis (e.g. to remove speaker effects)  #note: the inverse filter seems to offset the DC of the original signal, you might#need to highpass to remove DC.#we only listened to one channel, not sure if W would sound better with inv or#helm filter. 