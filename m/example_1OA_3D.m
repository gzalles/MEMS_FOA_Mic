## Copyright (C) 2023 Gabriel Zalles
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <https://www.gnu.org/licenses/>.

## script example for encoding and calibrating FOA array

## Author: Gabriel Zalles <gabrielzalles@Gabriels-MacBook-Pro.local>
## Created: 2023-02-25
 
clc; clear all; close all;
pkg load signal;

#load speaker filter (generated by REW) using calibrated u-mic.
# make sure to include calibration file
cd spkr-ir;
[spkr_ir, Fs] = audioread("MA329-Oct-22-filters-44k.wav");
cd ..
plot_on = 1;

#remove leading and trailing zeros
spkr_ir = spkr_ir(find(spkr_ir,1,'first'):find(spkr_ir,1,'last'));

#plot the filter in the time domain
if plot_on
  figure(1)
  plot(spkr_ir);
  axis tight; grid on;
  title("Speaker Compensation Filter (Time Domain)");
  ylabel("Amplitude");
  xlabel("Samples");
endif

#FFT the spkr response 
Nfft = 1024;
SPKR_IR = fft(spkr_ir, Nfft);
SPKR_IR_MAG = abs(SPKR_IR); #get mag

#plot the spkr response
freqVec = linspace(0, Fs/2, Nfft/2); #freq vector for plotting

if plot_on
  figure(2)
  plot(freqVec, 20*log10(SPKR_IR_MAG(1:end/2)));
  axis tight; grid on;
  title("Speaker Compensation Filter (Freq Domain)");
  ylabel("Magnitude in dB");
  xlabel("Frequency in Hz");
endif

#REW already windows the IR and provides a compensation EQ
#ScanIR does not window the data.

#load Helmholtz filter
[helm, Fs2] = audioread("naive-helm.wav");

#the helm wav file is just 5 filter coefficients 
#let's get the IR of the filter so we can see the response

delta = zeros(Nfft, 1);
delta(1) = 1; #delta function
helm_ir = filter(helm, 1, delta);#filter the delta function (1 = feedback coeff)
HELM_IR = fft(helm_ir, Nfft);#FFT the ir
HELM_IR_MAG = abs(HELM_IR);#get mag

if plot_on
  figure(3)
  plot(freqVec, 20*log10(HELM_IR_MAG(1:end/2)));
  axis tight; grid on;
  title("Helmholtz Filter (Freq Domain)");
  ylabel("Magnitude in dB");
  xlabel("Frequency in Hz");
endif

#we will use the Helmholtz filter to equalize our IRs from ScanIR
#many MEMS capsules have unwanted resonance above 10kHz 
#note: the SPH0645 does not (this is the capsule in the Ada I2S board)

#we load the two poses we have for the FOA mics
#CPMC365 (see AES147 paper)
cd data/aes147/may25;
load smlMulti2_side.mat; #load mems measurement ICS-40720 (non-anechoic), ScanIR
s1 = data; #struct 1
load smlMulti3_z;
s2 = data; #struct 2
cd ../../..;

#get params from data
D = size(s1, 2); #get number of meas in data (directions)
ir = s1.IR; #get the first ir (has Q columns)
ir_len = size(ir, 1); #get length of ir 
Q = size(ir, 2); #determine the number of sensors

Fs3 = specs.sampleRate; #get sampling rate of ir

#extract all the ir from structs
ir_all = getIR(s1, D, ir_len, Q); #custom function to extract IR
ir_all2 = getIR(s2, D, ir_len, Q);

#if the sample rates don't match (resample)
#     i.e. y = resample (x,1,2);  #downsample from 44100 to 22500 

if Fs ~= Fs3 #if Fs and Fs3 do not match
  ir_all = resampleIRs(Fs, Fs3, ir_all, D, Q, ir_len);
  ir_all2 = resampleIRs(Fs, Fs3, ir_all2, D, Q, ir_len);
  # resampleIRs(newFs, oldFs, ir_all, D, Q, ir_len);
endif

#we need to apply a windowing function, to prevent spectral leakage 
# (and make first value 0)
bm = blackman(ir_len*2); #make window function
win = zeros(ir_len, 1); #init mem for window
win(1:length(bm)/2) = bm(end/2+1:end); #put bm in win var

#plot one set of irs, from first direction (using pose 1 and 2)
if plot_on 
  figure(4)
  hold on;
  for i = 1:Q
    plot(ir_all(1, i, :));
    plot(ir_all2(1, i, :));
  endfor
  plot(win); #plot window
  hold off;
  axis tight; grid on;
  title("First IR (Pre-Processing)");
  ylabel("Amplitude");
  xlabel("Samples");
endif

#function retval = windowIRs(ir_all, D, Q, win);
ir_all = windowIRs(ir_all, D, Q, win);
ir_all2 = windowIRs(ir_all2, D, Q, win);

#function retval = helm_filt_IRs (ir_all, D, Q, helm)
ir_all = helm_filt_IRs(ir_all, D, Q, helm);
ir_all2 = helm_filt_IRs(ir_all2, D, Q, helm);

if D == 101
  #removing last response corresponding to 180 degs.
  # 0 degs should be symmetrical.
  ir_all = ir_all(1:D-1, :, :); 
  ir_all2 = ir_all2(1:D-1, :, :); 
  D = size(ir_all, 1); #recalculate D
endif

#filter all data with SPKR_IR 
IR_SINGLE = zeros(Nfft, 1); #init mem for single ir FFTd (Nfft by 1)
  
#first we need to FFT all the irs 
# which we've EQd with helmholtz filter and windowed
IR_ALL = FFT_IRs(ir_all, D, Q, Nfft);
IR_ALL2 = FFT_IRs(ir_all2, D, Q, Nfft);

#subsequently convolve with speaker EQ filter (compensate)
IR_ALL = conv_IRs (IR_ALL, D, Q, Nfft, SPKR_IR);
IR_ALL2 = conv_IRs (IR_ALL2, D, Q, Nfft, SPKR_IR);

#plot the FFT of the first meas. (d = 1) for Q sensors
if plot_on 
  figure(5)
  hold on;
  
  for i = 1:Q
    plot(freqVec, 20*log10(abs(IR_ALL(1, i, 1:end/2))));    
    plot(freqVec, 20*log10(abs(IR_ALL2(1, i, 1:end/2))));
  endfor
  
  hold off;
  axis tight; grid on;
  title("First IR FFT (Pre-AF EQ) [w/ helmholtz filter and spkr-EQ]");
  ylabel("Magnitude in dB");
  xlabel("Freq in Hz");
endif

#get Q DFRs, then get global DFR and generate 8 calibration filters

#get Q DFRs
DFRs = getDFR(IR_ALL, D, Q, Nfft);
DFRs2 = getDFR(IR_ALL2, D, Q, Nfft);

#let's plot these DFRs
if plot_on
  figure(6);
  hold on;
  
  for q = 1:1:Q
    
    DFR = DFRs(q, :); #extract first DFR
    #these are magnitudes already 
    plot(freqVec, 20*log10(DFR(1:end/2)));#decibel
    
    DFR = DFRs2(q, :); #extract first DFR
    #these are magnitudes already 
    plot(freqVec, 20*log10(DFR(1:end/2)));#decibel
  endfor
  
    axis tight; grid on;
    hold off;
    title("DFRs");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
    
endif

# now we have 4 DFRs for each pose
# we want 4 DFRs which average all poses 

P = 2; #number of poses

DFRs_local = zeros(Q, Nfft); 
#local refers to the fact that each capsulee has it's own DFR

#here we average all the poses
for q = 1:Q
  DFRs_local(q, :) = (DFRs(q, :) + DFRs2(q, :)) / P;
endfor

% DFR_global = sum(DFRs_local) ./ Q; #unused

# for the inverse filter we will use the local DFRs and the target
# will be the a delta function (not global DFR)
lim_vec = [20, 80, 17500, 20000];
regLow = 0.01; #low value for regularization vector

DELTA = fft(delta, Nfft); #get the frequency response of delta 
H_target = DELTA; #reassign variable name to avoid confusion 
binRes = Fs/Nfft; #bin resolution in Hz

#get inverse filters (min phase)
[H_inv, epsilon] = get_inv_filters(lim_vec, regLow, ...
  H_target, DFRs_local, Nfft, Fs);

H_inv1 = zeros(1, Nfft); #temp var for plotting

#plot inv filts in freq domain
if plot_on
  figure(7);
  for q = 1:1:Q
    
    H_inv1 = H_inv(q, :); #extract first inv filt
    H_inv1_mag = abs(H_inv1); #get mags
    plot(freqVec, 20*log10(H_inv1_mag(1:end/2)));#decibel
    hold on;
  endfor
    plot(freqVec, 20*log10(epsilon(1:end/2))); #plot epsilon 
    axis tight; grid on;
    hold off;
    title("Inverse Filters");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
endif

#now the filters are min phase, we can export and apply to our IRs
#A-format calibration (in preparation for plotting)

IR_ALL = conv_IRs(IR_ALL, D, Q, Nfft, H_inv);
IR_ALL2 = conv_IRs(IR_ALL2, D, Q, Nfft, H_inv);

#TODO: export AF filters, BF filters, enc-mat, test in RPP

# plot EQd A-format signals (only one direction)
if plot_on
  figure(8);
  hold on;
  for q = 1:1:Q
    IR_SINGLE(:, 1) = abs(IR_ALL(1, q, :));#extract one IR (EQd), get mag
    plot(freqVec, 20*log10(IR_SINGLE(1:end/2)));#decibel
    
    IR_SINGLE(:, 1) = abs(IR_ALL2(1, q, :));#extract one IR (EQd), get mag
    plot(freqVec, 20*log10(IR_SINGLE(1:end/2)));#decibel
  endfor
    axis tight; grid on;
    hold off;
    title("A-format EQd: Single Direction Phi = 0");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
    
endif

#lets calculate the matrix for encoding in FOA (should be equivalent to S/D eq.)

% FLU - front left up
% FRD - front right down
% BLD - back left down
% BRU - back right up

# for the capsule angles in FOA we have 45 degrees horizontal
elev = atan(sqrt(1/2)); #arctan(sqrt(1/2)) elevation (according to FLL)
elev = rad2deg(elev); #convert to degrees
Q_pos = [+45 +elev; -45 -elev; +135 -elev; -135 +elev]; #azi, elev

## shape of our enc-mat 
# (pre-transpose)

     #ACN0 || ACN1 || etc.
# q1  
# q2
# q3
# q4

N = 1; #ambisonic order 
numHarms = (N+1)^2; 

#simple check
if Q < numHarms
  disp("Q should be bigger than number of harmonics. Poor sampling");
endif

enc_mat = calc_enc_mat(Q_pos, N, Q); #calculate encoding matrix

#in order to plot we need to copy the data
if D == 100
  %% duplicate symmetric half
  %% to get 360 degrees. 
  temp = IR_ALL;                %copy the data 
  #already removed the last IR previously
  temp = flipud(temp);          %flip left/right
  IR_ALL = [IR_ALL; temp];      %append data
  clear temp;                   %we can get rid of the copy
  
  %% duplicate symmetric half
  %% to get 360 degrees. 
  temp = IR_ALL2;               %copy the data 
  #already removed the last IR previously
  temp = flipud(temp);          %flip left/right
  IR_ALL2 = [IR_ALL2; temp];    %append data
  clear temp;                   %we can get rid of the copy
  
  D = 200; 
endif

#now we need to encode all the A-format signals using the enc-mat. 
SH_ALL = encode_IRs(enc_mat, D, Q, Nfft, IR_ALL);
SH_ALL2 = encode_IRs(enc_mat, D, Q, Nfft, IR_ALL2);

#HERE, we get the Z harmonic from P2, and replace the data
#P1 is not a good sampling of Z.
SH_ALL(:, 3, :) = SH_ALL2(:, 3, :); #[W Y Z X] so Z is 3. 

clear SH_ALL2; #we don't need this var. avoid confusion. 

#with the IRs encoded now we should be able to plot the SHs. 
freq2plot = 1000;
k = floor(freq2plot/binRes); #bin for 1000Hz (closest to)
rad_vec = linspace (0, 2*pi, 200); %radian vector 0 to 360

if plot_on
  #close all;
  figure(9)
  
  for harm = 1:1:numHarms
    
    SH = SH_ALL(:, harm, k); #get one harmonic, at bin k
    SH_mag = abs(SH); #get mag
    #normalize (0 to 1) just for plot
    
    #SH_mag_norm = (SH_mag - min(SH_mag)) ./ ...
    #(max(SH_mag) - min(SH_mag)); #don't do this
    
    SH_mag_norm = SH_mag .* 1/(max(SH_mag));#do this
    #normalize just for plot
    
    polar(rad_vec, SH_mag_norm); #polar plot
    hold on;
  endfor

  title ("Polar Plot of ALL Harmonics at 1kHz (NORMALIZED)");
  axis tight; grid on;
  legend("W", "Y", "Z", "X");
  hold off; 
endif

disp("The P1 meas was taken 90 from the side, so X and Y are backwards.");

#note: when I normalize the W data things look totally screwed up.
#this is definitely what happened in AES143 paper, not sure why though...

#with the SH now available we can also try B-format EQing
#the idea is to find the max/peak of the SH and try to make f-res flat at that angle

[pk_IRs, SH_max_idx] = getSH_peaks(SH_ALL, k, Nfft, numHarms);

#let's first plot the response of these peaks 
if plot_on
  
  figure(10);
  
  for harm = 1:numHarms
    plot(freqVec, 20*log10(abs(pk_IRs(harm, 1:end/2))));#decibel
    hold on;
  endfor
  
    axis tight; grid on;
    hold off;
    title("Freq Response of SH Peaks");
    legend("W", "Y", "Z", "X");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
endif

#note: we have to account for SN3D normalization, make sure the inv filters
#don't mess up the normalization, we can multiply delta by norm coeffs
norm_coeffs = sn3d_all(numHarms, N); #for B-format EQs

#this is a special case since all norm coeffs = 1
[H_inv_BF, epsilon] = get_inv_filters(lim_vec, regLow, H_target, ...
  pk_IRs, Nfft, Fs);

#plot inv filts in freq domain for B-format calib. H's
if plot_on
  
  figure(11);
  
  for harm = 1:1:numHarms
    
    H_inv1 = H_inv_BF(harm, :); #extract first inv filt
    H_inv1_mag = abs(H_inv1); #get mags
    plot(freqVec, 20*log10(H_inv1_mag(1:end/2)));#decibel
    hold on;
    
  endfor
  
    axis tight; grid on;
    hold off;
    title("Inverse Filters for B-Format SHs (Peaks)");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
    
endif

#now we need to convolve the SH IRs with these inverse filters 

SH_ALL_EQ = zeros(size(SH_ALL)); %alloc mem
SH_ALL_EQ = conv_IRs(SH_ALL, D, Q, Nfft, H_inv_BF); %conv

#in order to evaluate their efficacy we have to compare with old SHs IRs
#at various frequencies

bins2plot = [250, 500, 1000, 2000, 4000, 8000];
bins2plot = floor(bins2plot/binRes); #bins for freqs (closest to)

harm = 2; %pick a harmonic to plot [WYZX]

disp("Figure 12 intentionally not normalized, to show effect of filter on SH.");

if plot_on
  #close all;
  figure(12)
  
  subplot (1, 2, 1); #left side is EQd plot
  
    for i = 1:length(bins2plot);
      k = bins2plot(i); #get one bin from array 
      SH = SH_ALL_EQ(:, harm, k); #get one harmonic, at bin k
      SH_mag = abs(SH); #get mag
      
      polar(rad_vec, SH_mag); #polar plot
      hold on;
    endfor
  
  title ("Polar Plot of 1 Harmonic (EQd)");
  axis tight; grid on;
  legend("250", "500", "1000", "2000", "4000", "8000");
  hold off;
  
  subplot (1, 2, 2); #right side is not EQd plot
  
    for i = 1:length(bins2plot);
      k = bins2plot(i); #get one bin from array 
      SH = SH_ALL(:, harm, k); #get one harmonic, at bin k
      SH_mag = abs(SH); #get mag
      
      polar(rad_vec, SH_mag); #polar plot
      hold on;
    endfor

  title ("Polar Plot 1 Harmonic (NOT EQd)");
  axis tight; grid on;
  legend("250", "500", "1000", "2000", "4000", "8000");
  hold off; 
  
endif

#we should also plot the freq response of the peaks, after EQing
if plot_on
  
  figure(13);
  
  for harm = 1:numHarms
    pkDir = SH_max_idx(harm);#get the SH IRs for the peaks 
    pk_IRs(harm, :) = SH_ALL_EQ(pkDir, harm, :); #extract 4 BF IRs (EQd) 
    #one at a time
    plot(freqVec, 20*log10(abs(pk_IRs(harm, 1:end/2))));#decibel
    hold on;
  endfor
  
    axis tight; grid on;
    hold off;
    title("Freq Response of SH Peaks (after EQ)");
    legend("W", "Y", "Z", "X");
    ylabel("Magnitude in dB");
    xlabel("Frequency in Hz");
endif

%import some A-format audio recorded with mic

%apply the processing AF_cal, enc_mat, BF_cal 

%listen to the difference (export audio)

%export decoder, and filters, ideally configuration files written here.






